<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>BatchVis + 실험 시작</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #F0F7FB;
      font-family: 'Roboto', sans-serif;
    }

    .container {
      display: flex;
      flex-direction: row;
      width: 96%;
      padding: 32px;
    }

    .left-panel {
      display: flex;
      flex-direction: column;
      width: 30%;
      margin-right: 24px;
    }

    .header {
      margin-bottom: 16px;
    }

    .title {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 36px;
      font-weight: 700;
      color: #3D2D4C;
      margin: 0;
    }

    .underline {
      border: none;
      height: 1px;
      background-color: #B7BCC9;
      margin-top: 6px;
    }

    .sidebar {
      background-color: #ffffff;
      border-radius: 4px;
      box-shadow: 0 0 11px rgba(128, 139, 157, 0.15);
      padding: 24px;
      font-size: 16px;
      line-height: 1.6;
      height: 794px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .display-area {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 16px;
      white-space: pre-line;
    }

    .input-box {
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: flex-end;
    }

    .input-box textarea {
      flex: 1;
      height: 48px;
      padding: 10px;
      font-size: 16px;
      resize: none;
      border-radius: 6px;
      border: 1px solid #ccc;
    }

    .input-box button {
      background-color: #8E12D5;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
    }

    .main-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 20px;
      padding-top: 85px;

    }

    .question-box label {
      font-weight: bold;
    }

    .question-box select {
      width: 100%;
      height: 40px;
      font-size: 16px;
      margin-top: 8px;
    }

    .response-box {
      background-color: #fff;
      border-radius: 4px;
      padding: 16px;
      box-shadow: 0 0 11px rgba(128, 139, 157, 0.15);
      position: relative;
    }

    .response-box button {
      position: absolute;
      bottom: 12px;
      right: 12px;
      background-color: #C5C0CA;
      border: none;
      padding: 6px 14px;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
    }

    /* 실험 시작 섹션 스타일 */
    .experiment-section {
      background-color: #ffffff;
      margin-top: 10px;
      padding: 2px 16px;
      border-radius: 6px;
      box-shadow: 0 0 11px rgba(128, 139, 157, 0.15);
      margin-bottom: 10px;
    }

    .experiment-section h2 {
      font-size: 20px;
      margin-bottom: 12px;
      color: #3D2D4C;
    }

    .experiment-section label {
      display: block;
      margin-top: 8px;
      font-weight: bold;
    }

    .experiment-section input {
      width: 85%;
      height: 32px;
      font-size: 16px;
      margin-top: 4px;
      padding: 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background-color: #f5f5f5;
      color: #000;
    }

    .experiment-section button {
      margin-top: 12px;
      background-color: #8E12D5;
      color: white;
      border: none;
      padding: 8px 14px;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
    }

    #result {
      margin-top: 20px;
    }
    
    .instruction-box {
        border: none;
        padding: 15px;
        margin: 10px 0;
        font-family: monospace;
        font-size: 14px;
        white-space: pre-wrap;
        line-height: 1.6;
    }
    .pagination {
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 20px 0;
        gap: 10px;
    }
    .pagination button {
        padding: 8px 12px;
        border: 1px solid #ccc;
        background: white;
        cursor: pointer;
    }
    .pagination button:disabled {
        background: #f0f0f0;
        cursor: not-allowed;
    }
    .pagination .current {
        background: #007bff;
        color: white;
        border-color: #007bff;
    }
    .loading {
        color: #666;
        font-style: italic;
    }
  </style>
  <script>
    let experimentNum = null;
    let experimentActive = false;
    let currentInstructions = [];
    let currentAnswers = [];  // 답변 데이터 추가
    let currentPage = 0;
    let instructionsPerPage = 1;
    let currentInput = '';  // 현재 입력값 저장

    async function startExperiment() {
        try {
            const res = await fetch('/start_experiment', { method: 'POST' });
            const data = await res.json();
            experimentNum = data.experiment_num;
            experimentActive = true;
            
            // 실험 시작 상태 설정
            isExperimentRunning = true;
            stopRequested = false;
            currentExperimentData = {
                experiment_num: data.experiment_num,
                timestamp: new Date().toISOString(),
                user_input: '',
                prompts: []
            };
            
            // experiment_num 입력 필드에 실험 번호 표시
            document.getElementById('experiment_num').value = experimentNum;
            document.getElementById('experiment_num').readOnly = true; // 수정 불가능하게 설정
            
            // 버튼 상태 변경
            document.getElementById('start-btn').style.display = 'none';
            document.getElementById('stop-btn').style.display = 'inline-block';
            document.getElementById('end-btn').style.display = 'inline-block';
            
            // 디버깅을 위한 콘솔 로그
            console.log('멈춤 버튼 표시:', document.getElementById('stop-btn').style.display);
            console.log('실험 완료 버튼 표시:', document.getElementById('end-btn').style.display);
            
            const display = document.getElementById('displayArea');
            display.innerHTML = `
                <div style="background-color: #e7f3ff; padding: 15px; border-radius: 8px; border-left: 4px solid #17a2b8;">
                    <p style="margin: 0; color: #0056b3;"><strong>실험 진행 중:</strong> 실험 번호 ${data.experiment_num}</p>
                    <p style="margin: 5px 0 0 0; color: #0056b3;">프롬프트를 입력하고 전송하거나, 멈춤 버튼을 눌러 현재까지의 결과를 저장하세요.</p>
                </div>
            `;
            
            document.getElementById('result').innerText = '실험을 시작했습니다. 이제 환자 정보를 입력하세요.';
        } catch (error) {
            document.getElementById('result').innerText = `오류 발생: ${error.message}`;
        }
    }

    async function stopExperiment() {
      if (!isExperimentRunning) {
        alert('실험을 먼저 시작하세요.');
        return;
      }
      
      stopRequested = true;
      isExperimentRunning = false;
      
      // 현재까지의 실험 데이터 저장
      if (currentExperimentData && currentExperimentData.user_input) {
        try {
          const response = await fetch('/save_experiment', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(currentExperimentData)
          });
          
          if (response.ok) {
            const result = await response.json();
            document.getElementById('result').innerHTML = `
              <div style="color: orange;">
                <strong>실험 중단됨:</strong> 현재까지의 결과가 저장되었습니다.<br>
                파일명: ${result.filename}
              </div>
            `;
          } else {
            document.getElementById('result').innerHTML = '<div style="color: red;">저장 실패</div>';
          }
        } catch (error) {
          console.error('저장 오류:', error);
          document.getElementById('result').innerHTML = '<div style="color: red;">저장 중 오류 발생</div>';
        }
      } else {
        document.getElementById('result').innerHTML = '<div style="color: orange;">실험 중단됨 (저장할 데이터 없음)</div>';
      }
      
      // 버튼 상태 복원
      document.getElementById('start-btn').style.display = 'inline-block';
      document.getElementById('stop-btn').style.display = 'none';
      document.getElementById('end-btn').style.display = 'none';
      
      // displayArea 업데이트
      document.getElementById('displayArea').innerHTML = `
        <div style="background-color: #fff3cd; padding: 15px; border-radius: 8px; border-left: 4px solid #ffc107;">
          <p style="margin: 0; color: #856404;"><strong>실험 중단됨:</strong> 새로운 실험을 시작하려면 "실험 시작" 버튼을 클릭하세요.</p>
        </div>
      `;
      
      // 실험 상태 초기화
      experimentActive = false;
      currentExperimentData = null;
    }

    function endExperiment() {
      if (!experimentActive) {
        alert('실험을 먼저 시작하세요.');
        return;
      }
      experimentActive = false;
      document.getElementById('result').innerText = '실험 완료';
      
      // 버튼 상태 복원
      document.getElementById('start-btn').style.display = 'inline-block';
      document.getElementById('stop-btn').style.display = 'none';
      document.getElementById('end-btn').style.display = 'none';
    }

    async function checkBatchStatus() {
        const batchId = document.getElementById('batch_id').value.trim();
        if (!batchId) {
            alert('Batch ID를 입력해주세요.');
            return;
        }
        
        const resultDiv = document.getElementById('batch-status-result');
        resultDiv.innerHTML = '<div style="color: #17a2b8;">Batch 상태 확인 중...</div>';
        
        try {
            const response = await fetch(`/check_batch_status/${batchId}`);
            const data = await response.json();
            
            if (response.ok) {
                if (data.status === 'completed') {
                    resultDiv.innerHTML = `
                        <div style="color: #28a745; background-color: #d4edda; padding: 10px; border-radius: 4px; border: 1px solid #c3e6cb;">
                            <strong>✅ 응답모두 받음!</strong><br>
                            총 응답 수: ${data.total_responses}개<br>
                            저장 파일: ${data.saved_file}<br>
                            완료 시간: ${data.batch_info.completed_at || 'N/A'}
                        </div>
                    `;
                    console.log("응답모두 받음");
                } else if (data.status === 'failed') {
                    resultDiv.innerHTML = `
                        <div style="color: #dc3545; background-color: #f8d7da; padding: 10px; border-radius: 4px; border: 1px solid #f5c6cb;">
                            <strong>❌ Batch 처리 실패</strong><br>
                            오류: ${data.error || '알 수 없는 오류'}
                        </div>
                    `;
                } else if (data.status === 'expired') {
                    resultDiv.innerHTML = `
                        <div style="color: #ffc107; background-color: #fff3cd; padding: 10px; border-radius: 4px; border: 1px solid #ffeaa7;">
                            <strong>⚠️ Batch 처리 만료</strong><br>
                            Batch ID: ${data.batch_info.id}
                        </div>
                    `;
                } else {
                    resultDiv.innerHTML = `
                        <div style="color: #17a2b8; background-color: #d1ecf1; padding: 10px; border-radius: 4px; border: 1px solid #bee5eb;">
                            <strong>🔄 Batch 처리 중...</strong><br>
                            상태: ${data.status}<br>
                            생성 시간: ${data.batch_info.created_at || 'N/A'}
                        </div>
                    `;
                }
            } else {
                resultDiv.innerHTML = `
                    <div style="color: #dc3545; background-color: #f8d7da; padding: 10px; border-radius: 4px; border: 1px solid #f5c6cb;">
                        <strong>❌ 상태 확인 실패</strong><br>
                        오류: ${data.message || '알 수 없는 오류'}
                    </div>
                `;
            }
        } catch (error) {
            resultDiv.innerHTML = `
                <div style="color: #dc3545; background-color: #f8d7da; padding: 10px; border-radius: 4px; border: 1px solid #f5c6cb;">
                    <strong>❌ 네트워크 오류</strong><br>
                    오류: ${error.message}
                </div>
            `;
        }
    }

    async function submitText() {
        const input = document.getElementById('inputText').value;
        const display = document.getElementById('displayArea');
        const loading = document.getElementById('loading');

        if (!input || !experimentActive) {
            alert('실험을 먼저 시작하고 환자 정보를 입력하세요.');
            return;
        }

        // 입력값 저장
        currentInput = input;
        
        // 실험 데이터 업데이트
        if (currentExperimentData) {
          currentExperimentData.user_input = input;
        }
        
        display.innerHTML = `<div style='margin-bottom:10px;'><strong>입력:</strong> ${input}</div>`;
        loading.style.display = 'block';
        loading.innerText = '가상환자 조합 생성 중...';

        try {
            // 1단계: Instruction 생성
            const instructionRes = await fetch('/generate_instructions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ user_input: input })
            });
            let instructionData;
            if (instructionRes.ok && instructionRes.headers.get('content-type')?.includes('application/json')) {
                instructionData = await instructionRes.json();
            } else {
                const text = await instructionRes.text();
                throw new Error('서버 오류: ' + text);
            }
            currentInstructions = instructionData.instructions || [];
            currentPage = 0;
            instructionsPerPage = 1;
            if (currentInstructions.length > 0) {
                displayInstruction(currentPage);
                showPagination();
                loading.innerText = `가상환자 조합 생성 완료! (${currentInstructions.length}개 조합)`;
                // 2단계: Batch 처리
                loading.innerText = 'Batch API 작업 제출 중...';
                const batchRes = await fetch('/process_qa_batch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        experiment_num: experimentNum,
                        user_input: input
                    })
                });
                let batchData = await batchRes.json();
                if (batchRes.ok) {
                    display.innerHTML = `
                        <div style='margin-bottom:10px;'><strong>입력:</strong> ${input}</div>
                        <div style='margin-bottom:10px;'><strong>Batch ID:</strong> ${batchData.batch_id}</div>
                        <div style='margin-bottom:10px;'><strong>요청 수:</strong> ${batchData.request_count}개</div>
                        <div style='margin-bottom:10px;'><strong>조합 수:</strong> ${batchData.combination_count}개</div>
                        <div style='margin-bottom:10px;'><strong>질문 수:</strong> ${batchData.questions_count}개</div>
                        <div style='margin-bottom:10px;'><strong>예상 완료:</strong> 2-4시간 후</div>
                        <div style='margin-bottom:10px;'><strong>대시보드:</strong> <a href="${batchData.openai_dashboard_url}" target="_blank">OpenAI Batch 대시보드</a></div>
                    `;
                    
                    // Batch 상태 확인 섹션 표시 및 Batch ID 설정
                    document.getElementById('batch-status-section').style.display = 'block';
                    document.getElementById('batch_id').value = batchData.batch_id;
                    
                    // loading.innerText = 'Batch 작업이 제출되었습니다. 2-4시간 후 결과 파일을 확인하세요.';
                    // document.getElementById('result').innerText = `Batch 작업 제출 완료! (${batchData.request_count}개 요청)`;
                    document.getElementById('result');
                } else {
                    throw new Error(batchData.error || 'Batch 작업 제출 실패');
                }
                setTimeout(() => {
                    loading.style.display = 'none';
                }, 3000);
            } else {
                loading.innerText = '가상환자 조합 생성 실패';
            }
        } catch (error) {
            document.getElementById('result').innerText = `오류 발생: ${error.message}`;
            loading.innerText = '오류 발생';
        }
        document.getElementById('inputText').value = '';
    }

    function displayInstruction(pageIndex) {
        const display = document.getElementById('displayArea');
        
        if (currentInstructions.length === 0) return;
        
        const instruction = currentInstructions[pageIndex];
        // detail 정보 문자열 생성
        let detailStr = '';
        if (instruction.type === 'personality') {
            detailStr = Object.entries(instruction.detail || {}).map(([k,v]) => `${k}: ${v}`).join(', ');
        } else if (instruction.type === 'character') {
            detailStr = Object.entries(instruction.detail || {}).map(([k,v]) => `${k}: ${v}`).join(', ');
        } else if (instruction.type === 'personality+character') {
            const t = instruction.detail?.temperament || {};
            const c = instruction.detail?.character || {};
            detailStr = `[Temperament] ` + Object.entries(t).map(([k,v]) => `${k}: ${v}`).join(', ') + ' | [Character] ' + Object.entries(c).map(([k,v]) => `${k}: ${v}`).join(', ');
        }
        
        display.innerHTML = `
            <div style='margin-bottom:10px;'><strong>입력:</strong> ${currentInput}</div>
            <div style='margin-bottom:10px;'><strong>조합:</strong> ${detailStr}</div>
            <div class="instruction-box">
                <strong>[${(instruction.type || 'UNKNOWN').toUpperCase()}]</strong>
                ${instruction.prompt || instruction.virtual_patient_prompt || '프롬프트 없음'}
            </div>
        `;
        
        updatePagination();
    }

    async function displayResponsesByQuestion(selectedQuestionIdx) {
        console.log('🚀 displayResponsesByQuestion 호출됨:', selectedQuestionIdx);
        console.log('🔍 currentInstructions 길이:', currentInstructions.length);
        
        const mainPanel = document.querySelector('.main-panel');
        console.log('🔍 mainPanel 찾음:', mainPanel);
        
        // 기존 response-box들 제거
        const existingResponses = mainPanel.querySelectorAll('.response-box');
        existingResponses.forEach(box => box.remove());
        console.log('🔍 기존 response-box 제거됨');
        
        // 질문 텍스트 가져오기
        const select = document.getElementById('question');
        const questionText = select.options[selectedQuestionIdx + 1]?.textContent;
        console.log('🔍 선택된 질문 텍스트:', questionText);
        
        if (!questionText) {
            console.log('❌ 질문 텍스트를 찾을 수 없음');
            return;
        }
        
        // 현재 질문에 대한 답변이 이미 있는지 확인
        let hasExistingAnswers = false;
        if (currentInstructions.length > 0) {
            hasExistingAnswers = currentInstructions.some(inst => 
                inst.qa && inst.qa[selectedQuestionIdx] && inst.qa[selectedQuestionIdx].answer
            );
        }
        
        // 답변 대기중 UI 미리 표시
        currentInstructions.forEach((inst, idx) => {
            let detailStr = '';
            if (inst.type === 'personality') {
                detailStr = Object.entries(inst.detail || {}).map(([k,v]) => `${k}: ${v}`).join(', ');
            } else if (inst.type === 'character') {
                detailStr = Object.entries(inst.detail || {}).map(([k,v]) => `${k}: ${v}`).join(', ');
            } else if (inst.type === 'personality+character') {
                const t = inst.detail?.temperament || {};
                const c = inst.detail?.character || {};
                detailStr = `[Temperament] ` + Object.entries(t).map(([k,v]) => `${k}: ${v}`).join(', ') + ' | [Character] ' + Object.entries(c).map(([k,v]) => `${k}: ${v}`).join(', ');
            }
            const responseBox = document.createElement('div');
            responseBox.className = 'response-box';
            
            // 이미 답변이 있으면 바로 표시
            if (inst.qa && inst.qa[selectedQuestionIdx] && inst.qa[selectedQuestionIdx].answer) {
                const qa = inst.qa[selectedQuestionIdx];
                responseBox.innerHTML = `
                    <div style="font-size:13px; color:#888; margin-bottom:6px;">${inst.type?.toUpperCase() || 'UNKNOWN'} | ${detailStr}</div>
                    <p>${qa.answer || '답변 없음'}</p>
                    <button>선택</button>
                `;
            } else {
                responseBox.innerHTML = `
                    <div style="font-size:13px; color:#888; margin-bottom:6px;">${inst.type?.toUpperCase() || 'UNKNOWN'} | ${detailStr}</div>
                    <p style="color:#aaa;">답변 대기중...</p>
                `;
            }
            mainPanel.appendChild(responseBox);
        });
        
        // 이미 답변이 있으면 API 호출하지 않음
        if (hasExistingAnswers) {
            return;
        }
        
        // 백엔드에 batch 요청
        console.log('🔍 API 호출 전 값 확인:');
        console.log('  - experiment_num:', experimentNum);
        console.log('  - currentInput:', currentInput);
        console.log('  - question_text:', questionText);
        console.log('  - currentInstructions 길이:', currentInstructions.length);
        
        let data;
        try {
            const res = await fetch('/process_qa_one_question', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    experiment_num: experimentNum,
                    instructions: currentInstructions,
                    user_input: currentInput,
                    question_text: questionText
                })
            });
            if (res.ok && res.headers.get('content-type')?.includes('application/json')) {
                data = await res.json();
            } else {
                const text = await res.text();
                throw new Error('서버 오류: ' + text);
            }
        } catch (err) {
            document.getElementById('result').innerText = `오류 발생: ${err.message}`;
            return;
        }
        // 답변 오면 UI 갱신하고 currentInstructions에 저장
        const boxes = mainPanel.querySelectorAll('.response-box');
        data.answers.forEach((ans, idx) => {
            if (!boxes[idx]) return;
            let detailStr = '';
            if (ans.type === 'personality') {
                detailStr = Object.entries(ans.detail || {}).map(([k,v]) => `${k}: ${v}`).join(', ');
            } else if (ans.type === 'character') {
                detailStr = Object.entries(ans.detail || {}).map(([k,v]) => `${k}: ${v}`).join(', ');
            } else if (ans.type === 'personality+character') {
                const t = ans.detail?.temperament || {};
                const c = ans.detail?.character || {};
                detailStr = `[Temperament] ` + Object.entries(t).map(([k,v]) => `${k}: ${v}`).join(', ') + ' | [Character] ' + Object.entries(c).map(([k,v]) => `${k}: ${v}`).join(', ');
            }
            boxes[idx].innerHTML = `
                <div style="font-size:13px; color:#888; margin-bottom:6px;">${ans.type?.toUpperCase() || 'UNKNOWN'} | ${detailStr}</div>
                <p>${ans.answer || '답변 없음'}</p>
                <button>선택</button>
            `;
            
            // currentInstructions에 답변 저장
            if (currentInstructions[idx]) {
                if (!currentInstructions[idx].qa) {
                    currentInstructions[idx].qa = [];
                }
                currentInstructions[idx].qa[selectedQuestionIdx] = ans;
            }
        });
    }

    function showPagination() {
        const pagination = document.getElementById('pagination');
        pagination.style.display = 'flex';
        updatePagination();
    }

    function updatePagination() {
        const pageInfo = document.getElementById('pageInfo');
        const totalPages = currentInstructions.length;
        pageInfo.innerText = `${currentPage + 1} / ${totalPages}`;
        
        // 버튼 활성화/비활성화
        const prevBtn = pagination.querySelector('button:first-child');
        const nextBtn = pagination.querySelector('button:last-child');
        
        prevBtn.disabled = currentPage === 0;
        nextBtn.disabled = currentPage === totalPages - 1;
    }

    function prevPage() {
        if (currentPage > 0) {
            currentPage--;
            displayInstruction(currentPage);
            // 현재 선택된 질문 인덱스에 맞춰 답변 표시
            const select = document.getElementById('question');
            const idx = select.selectedIndex - 1;
            if (idx >= 0) {
                displayResponsesByQuestion(idx);
            }
        }
    }

    function nextPage() {
        if (currentPage < currentInstructions.length - 1) {
            currentPage++;
            displayInstruction(currentPage);
            // 현재 선택된 질문 인덱스에 맞춰 답변 표시
            const select = document.getElementById('question');
            const idx = select.selectedIndex - 1;
            if (idx >= 0) {
                displayResponsesByQuestion(idx);
            }
        }
    }

    async function populateQuestions() {
      const res = await fetch('/static/questions.json');
      if (res.ok) {
        const questions = await res.json();
        const select = document.getElementById('question');
        select.innerHTML = '<option>문항을 선택하세요</option>';
        questions.forEach((q, idx) => {
          const opt = document.createElement('option');
          opt.value = idx + 1;
          opt.textContent = q.text;
          select.appendChild(opt);
        });
        
        // displayArea에 기본 정보와 프롬프트 표시
        const displayArea = document.getElementById('displayArea');
        displayArea.innerHTML = `
          <div style="margin-bottom: 20px;">
            <h3 style="color: #333; margin-bottom: 15px;">📋 기본 정보</h3>
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #007bff;">
              <p><strong>사용 가능한 질문:</strong> ${questions.length}개</p>
              <p><strong>질문 예시:</strong></p>
              <ul style="margin: 10px 0; padding-left: 20px;">
                ${questions.slice(0, 3).map(q => `<li>${q.text}</li>`).join('')}
                ${questions.length > 3 ? '<li>... 등</li>' : ''}
              </ul>
            </div>
          </div>
          
          <div style="margin-bottom: 20px;">
            <h3 style="color: #333; margin-bottom: 15px;">💬 프롬프트 입력</h3>
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #28a745;">
              <p><strong>사용법:</strong></p>
              <ol style="margin: 10px 0; padding-left: 20px;">
                <li>실험 시작 버튼을 클릭하여 새 실험을 시작하거나</li>
                <li>저장된 실험을 불러와서 기존 데이터를 확인하세요</li>
                <li>질문을 선택하면 해당 응답을 볼 수 있습니다</li>
              </ol>
            </div>
          </div>
          
          <div style="background: #e7f3ff; padding: 15px; border-radius: 8px; border-left: 4px solid #17a2b8;">
            <p style="margin: 0; color: #0056b3;"><strong>💡 팁:</strong> 실험을 불러온 후 질문을 선택하면 각 페르소나별 응답을 확인할 수 있습니다.</p>
          </div>
        `;
      }
    }

    async function fetchExperimentList() {
      const select = document.getElementById('loadExperimentSelect');
      select.innerHTML = '<option value="">저장된 실험을 선택하세요</option>';
      console.log('🔍 실험 목록 불러오기 시작');
      
      try {
        console.log('🔍 /list_experiments API 호출 중...');
        const res = await fetch('/list_experiments');
        console.log('🔍 API 응답 상태:', res.status, res.statusText);
        
        if (res.ok) {
          const list = await res.json();
          console.log('✅ 실험 목록 로드 성공:', list);
          list.forEach(item => {
            const label = `${item.date} | ${item.name} | ${item.age}`;
            const opt = document.createElement('option');
            opt.value = item.filename;
            opt.textContent = label;
            select.appendChild(opt);
          });
          console.log(`✅ ${list.length}개 실험 옵션 추가됨`);
        } else {
          console.error('❌ API 응답 실패:', res.status, res.statusText);
          const errorText = await res.text();
          console.error('❌ 에러 내용:', errorText);
          select.innerHTML = '<option>API 응답 실패</option>';
        }
      } catch (e) {
        console.error('❌ fetchExperimentList 에러:', e);
        select.innerHTML = '<option>불러오기 실패</option>';
      }
    }
    async function loadSelectedExperiment() {
      const select = document.getElementById('loadExperimentSelect');
      const filename = select.value;
      if (!filename) return;
      
      console.log('🔍 실험 불러오기 시작:', filename);
      
      try {
        // 직접 파일 읽기 시도
        const res = await fetch(`/responses/${filename}`);
        if (res.ok) {
          const data = await res.json();
          console.log('✅ 실험 데이터 로드 성공:', data);
          console.log('🔍 데이터 구조:', Object.keys(data));
          
          // user_input 설정 수정
          const userInput = data.user_input || (data.history && data.history[0] ? data.history[0].user_input : '');
          document.getElementById('inputText').value = userInput;
          
          // 다양한 데이터 구조 시도
          let prompts = null;
          console.log('🔍 데이터 상세 구조:', data);
          console.log('🔍 user_input 확인:', userInput);
          
          if (data.prompts && data.prompts.length > 0) {
            prompts = data.prompts;
            console.log('✅ prompts에서 데이터 찾음:', prompts.length);
                      } else if (data.history && data.history.length > 0) {
              if (data.history[0].prompts) {
                prompts = data.history[0].prompts;
                console.log('✅ history[0].prompts에서 데이터 찾음:', prompts.length);
              } else if (data.history[0].answers) {
                // JSON의 모든 질문과 답변을 찾아서 prompts 구조로 변환
                console.log('🔍 JSON에서 모든 질문과 답변 찾기 시작');
                
                // 모든 history 항목에서 질문과 답변 수집
                const allQuestions = [];
                const questionAnswerMap = new Map(); // 질문별 답변 맵
                
                data.history.forEach((historyItem, historyIdx) => {
                  if (historyItem.question_text && historyItem.answers) {
                    allQuestions.push(historyItem.question_text);
                    console.log(`🔍 질문 ${historyIdx + 1}: ${historyItem.question_text}`);
                    
                    // 각 답변을 질문별로 저장
                    historyItem.answers.forEach((answer, answerIdx) => {
                      const key = `${historyItem.question_text}_${answerIdx}`;
                      questionAnswerMap.set(key, {
                        question: historyItem.question_text,
                        answer: answer.answer,
                        type: answer.type,
                        detail: answer.detail,
                        personality: answer.personality
                      });
                    });
                  }
                });
                
                console.log('🔍 발견된 총 질문 수:', allQuestions.length);
                console.log('🔍 질문별 답변 맵:', questionAnswerMap);
                
                // prompts 구조로 변환 - 수정된 로직
                if (allQuestions.length > 0) {
                  prompts = data.history[0].answers.map((answer, answerIdx) => {
                    const allQa = [];
                    
                    // 모든 질문에 대해 답변 찾기
                    allQuestions.forEach((questionText, questionIdx) => {
                      const key = `${questionText}_${answerIdx}`;
                      const qaData = questionAnswerMap.get(key);
                      
                      if (qaData) {
                        allQa.push({
                          question: questionText,
                          answer: qaData.answer
                        });
                      } else {
                        allQa.push({
                          question: questionText,
                          answer: null // 해당 질문에 대한 답변이 없음
                        });
                      }
                    });
                    
                    return {
                      type: answer.type,
                      detail: answer.detail,
                      personality: answer.personality,
                      qa: allQa
                    };
                  });
                  
                  console.log('✅ history에서 모든 질문과 답변을 찾아서 변환됨:', prompts.length);
                  console.log('🔍 각 prompt의 qa 길이:', prompts[0]?.qa?.length);
                } else {
                  // 질문이 없는 경우 answers 자체를 prompts로 사용
                  prompts = data.history[0].answers.map(answer => ({
                    type: answer.type,
                    detail: answer.detail,
                    personality: answer.personality,
                    qa: [{
                      question: '질문',
                      answer: answer.answer
                    }]
                  }));
                  console.log('✅ answers를 직접 prompts로 변환:', prompts.length);
                }
              } else if (data.history[0].instructions) {
                prompts = data.history[0].instructions;
                console.log('✅ history[0].instructions에서 데이터 찾음:', prompts.length);
              }
            } else if (data.instructions && data.instructions.length > 0) {
            prompts = data.instructions;
            console.log('✅ instructions에서 데이터 찾음:', prompts.length);
          } else if (Array.isArray(data) && data.length > 0) {
            // 데이터가 배열인 경우
            console.log('✅ 배열 형태의 데이터 발견:', data.length);
            if (data[0] && data[0].prompts) {
              prompts = data[0].prompts;
              console.log('✅ data[0].prompts에서 데이터 찾음:', prompts.length);
            } else if (data[0] && data[0].instructions) {
              prompts = data[0].instructions;
              console.log('✅ data[0].instructions에서 데이터 찾음:', prompts.length);
            } else {
              // 배열 자체가 prompts인 경우
              prompts = data;
              console.log('✅ 배열 자체가 prompts 데이터:', prompts.length);
            }
          }
          
          if (prompts && prompts.length > 0) {
            currentInstructions = prompts;
            currentInput = userInput; // 수정된 userInput 사용
            // experimentNum 설정 추가
            experimentNum = data.experiment_num || filename.replace('.json', '');
            currentPage = 0;
            console.log('✅ currentInstructions 설정됨:', currentInstructions.length);
            console.log('✅ experimentNum 설정됨:', experimentNum);
            console.log('✅ currentInput 설정됨:', currentInput);
            
            // 첫 번째 instruction 표시
            displayInstruction(currentPage);
            showPagination();
            
            // 자동으로 첫 번째 질문 선택하여 응답 표시
            const questionSelect = document.getElementById('question');
            console.log('🔍 질문 선택 옵션 개수:', questionSelect.options.length);
            
            if (questionSelect.options.length > 1) {
              questionSelect.selectedIndex = 1; // 첫 번째 질문 선택 (0번은 "문항을 선택하세요")
              console.log('✅ 첫 번째 질문 선택됨, displayResponsesByQuestion 호출');
              displayResponsesByQuestion(0); // 첫 번째 질문(인덱스 0)에 대한 응답 표시
            } else {
              console.log('❌ 질문 옵션이 부족함');
            }
          } else {
            console.log('❌ prompts 데이터를 찾을 수 없음');
            console.log('🔍 사용 가능한 키들:', Object.keys(data));
          }
        } else {
          console.error('❌ API 응답 실패:', res.status);
          alert('불러오기 실패');
        }
      } catch (e) {
        console.error('❌ 실험 불러오기 오류:', e);
        alert('불러오기 실패');
      }
    }



    // 전역 변수로 실험 상태 관리
    let isExperimentRunning = false;
    let currentExperimentData = null;
    let stopRequested = false;

    window.addEventListener('DOMContentLoaded', () => {
      document.getElementById('start-btn').onclick = startExperiment;
      document.getElementById('stop-btn').onclick = stopExperiment;
      document.getElementById('end-btn').onclick = endExperiment;
      
      // 버튼 초기 상태 설정
      document.getElementById('start-btn').style.display = 'inline-block';
      document.getElementById('stop-btn').style.display = 'none';
      document.getElementById('end-btn').style.display = 'inline-block';
      
      populateQuestions();
      
      // 질문 선택 이벤트
      document.getElementById('question').addEventListener('change', function() {
        const idx = this.selectedIndex - 1;
        if (idx >= 0) {
          displayResponsesByQuestion(idx);
        }
      });
      fetchExperimentList();
    });
  </script>
</head>
<body>
  <div class="container">
    <!-- 왼쪽 패널 -->
    <div class="left-panel">
      <div class="header">
        <h1 class="title">BatchVis</h1>
        <hr class="underline" />
      </div>
      
      <!-- experiment-section을 위로 이동 -->
      <div class="experiment-section">
        <h2>실험 시작</h2>
        <form id="experiment-form" onsubmit="return false;">
          <label for="experiment_num">실험 번호:</label>
          <input type="text" id="experiment_num" name="experiment_num" placeholder="실험 시작 버튼 클릭시 번호가 자동으로 할당됩니다" readonly />
          <button type="button" id="start-btn">실험 시작</button>
          <button type="button" id="stop-btn" style="display: none; background-color: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 4px;">멈춤</button>
          <button type="button" id="end-btn">실험 완료</button>
        </form>
        
        <!-- Batch 상태 확인 섹션 추가 -->
        <div id="batch-status-section" style="display: none; margin-top: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 8px; border-left: 4px solid #17a2b8;">
          <h3 style="margin-top: 0; color: #17a2b8;">Batch API 상태 확인</h3>
          <label for="batch_id">Batch ID:</label>
          <input type="text" id="batch_id" placeholder="Batch ID를 입력하세요" style="width: 300px; margin-right: 10px;">
          <button onclick="checkBatchStatus()" style="background-color: #17a2b8; color: white; border: none; padding: 8px 16px; border-radius: 4px;">상태 확인</button>
          <div id="batch-status-result" style="margin-top: 10px;"></div>
        </div>
        
        <div id="result"></div>
      </div>

      <!-- sidebar를 아래로 이동 -->
      <div class="sidebar">
        <div class="display-area" id="displayArea">
            <div>실험을 시작하려면 "실험 시작" 버튼을 클릭하세요.</div>
        </div>

        <div class="pagination" id="pagination" style="display: none;">
            <button onclick="prevPage()">&lt;</button>
            <span id="pageInfo">1 / 1</span>
            <button onclick="nextPage()">&gt;</button>
        </div>
        
        <div id="loading" class="loading" style="display: none;">처리 중...</div>
        <div id="result" class="result"></div>
        <div class="input-box" style="flex-direction: column; align-items: stretch; gap: 8px;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <select id="loadExperimentSelect"   style="flex: 1; height: 40px; font-size: 16px;"></select>
            <button type="button" onclick="loadSelectedExperiment()">불러<br>오기</button>
          </div>
          <textarea id="inputText" placeholder="여기에 프롬프트를 입력하세요." rows="3"></textarea>
          <button onclick="submitText()">전송</button>
        </div>
      </div>
    </div>

    <!-- 오른쪽 패널 -->
    <div class="main-panel">
      <div class="question-box">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
          <label for="question" style="font-size: 20px;">질문 선택:</label>
          <a href="/visualization" class="analysis-btn" style="font-size: 16px; padding: 10px 20px; background-color: #8E12D5; color: white; text-decoration: none; border-radius: 6px; display: inline-block;">
            시각화하러 가기
          </a>
        </div>
        <select id="question" style="width: 1000px; height: 35px; font-size: 14px;">
          <!-- 질문 목록은 JS에서 동적으로 로드 -->
        </select>
      </div>


      <!-- displayArea 추가 -->
      <div id="displayArea" style="margin-top: 20px; padding: 20px; background-color: #f8f9fa; border-radius: 8px;">
        <!-- 기본 정보와 프롬프트가 여기에 표시됩니다 -->
      </div>

      <!-- response-box들은 동적으로 생성됨 -->
    </div>
  </div>
</body>
</html>
